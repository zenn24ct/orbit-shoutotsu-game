<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Asteroid Roll</title>
<style>
  html,body{
    height:100%;margin:0;
    background:#05070b;
    display:flex;align-items:center;justify-content:center;
    font-family:system-ui;
  }
  canvas{
    background:#0a121d;
    border-radius:8px;
    box-shadow:0 8px 28px rgba(0,0,0,.6);
  }
  #hud{
    position:fixed;top:12px;left:12px;
    color:#cfe7ff;font-size:14px;font-weight:600;
  }
  #msg{
    position:fixed;top:50%;left:50%;
    transform:translate(-50%,-50%);
    background:rgba(0,0,0,.45);
    padding:12px 18px;border-radius:8px;
    color:#fff;font-size:18px;text-align:center;
    display:none;
  }
</style>
</head>
<body>

<canvas id="game" width="480" height="640"></canvas>
<div id="hud">Score: 0</div>
<div id="msg">Game Over</div>

<script>
// -------------------- 基本設定 --------------------
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const W = canvas.width, H = canvas.height;

let last = 0, running = true;
let score = 0;
let gameOver = false;

// -------------------- PNG読み込み --------------------
const imgRocket = new Image();
const imgStone1 = new Image();
const imgStone2 = new Image();

imgRocket.src = "/images/rocket.png";
imgStone1.src = "/images/inseki01.png";
imgStone2.src = "/images/inseki02.png";

// -------------------- プレイヤー --------------------
const player = {
  x: W/2,
  y: H - 60,
  r: 24,
  speed: 320
};

// -------------------- 隕石 --------------------
const stones = [];
const stoneTypes = [
  { img: imgStone1, size: 42, speedMin: 80, speedMax: 150 },
  { img: imgStone2, size: 66, speedMin: 50, speedMax: 120 }
];

function spawnStone(){
  const t = Math.random() < 0.5 ? 0 : 1;
  const type = stoneTypes[t];

  return {
    x: Math.random()*(W-type.size*2) + type.size,
    y: -type.size,
    r: type.size/2,
    vy: rand(type.speedMin, type.speedMax),
    rot: Math.random()*Math.PI*2,
    rotSpd: (Math.random()-0.5)*3,
    img: type.img,
    size: type.size
  };
}

function rand(a,b){ return Math.random()*(b-a)+a; }

// -------------------- 入力 --------------------
const keys = {};
window.addEventListener("keydown", e=>{ keys[e.key] = true; });
window.addEventListener("keyup",   e=>{ keys[e.key] = false; });

canvas.addEventListener("mousemove", e=>{
  const r = canvas.getBoundingClientRect();
  const mx = (e.clientX - r.left) * (canvas.width / r.width);
  player.x = mx;
});

canvas.addEventListener("click", ()=>{
  if(gameOver) restart();
});

// -------------------- 再スタート --------------------
function restart(){
  stones.length = 0;
  score = 0;
  gameOver = false;
  document.getElementById("msg").style.display = "none";
  last = performance.now();
  running = true;
  loop(last);
}

// -------------------- 更新 --------------------
function update(dt){
  if(gameOver) return;

  // プレイヤー移動（左右）
  let move = 0;
  if(keys["ArrowLeft"] || keys["a"]) move -= 1;
  if(keys["ArrowRight"] || keys["d"]) move += 1;
  player.x += move * player.speed * dt;

  // 画面内制限
  player.x = Math.max(player.r, Math.min(W-player.r, player.x));

  // 隕石生成（やや高頻度）
  if(Math.random() < 0.04){
    stones.push(spawnStone());
  }

  // 隕石更新
  for(let i=stones.length-1;i>=0;i--){
    const s = stones[i];
    s.y += s.vy * dt;
    s.rot += s.rotSpd * dt;

    // プレイヤー衝突
    if(isCollide(s,player)){
      gameOver = true;
      running = false;
      document.getElementById("msg").style.display = "block";
    }

    // 画面外処理
    if(s.y - s.r > H){
      stones.splice(i,1);
    }
  }

  // スコア（秒）
  score += dt;
  document.getElementById("hud").textContent = "Score: " + Math.floor(score);
}

// -------------------- 描画 --------------------
function draw(){
  ctx.clearRect(0,0,W,H);

  // 隕石
  stones.forEach(s=>{
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.rotate(s.rot);
    ctx.drawImage(s.img, -s.size/2, -s.size/2, s.size, s.size);
    ctx.restore();
  });

  // ロケット
  ctx.drawImage(imgRocket, player.x-player.r, player.y-player.r, player.r*2, player.r*2);
}

// -------------------- 衝突（円×円） --------------------
function isCollide(a,b){
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return dx*dx + dy*dy < (a.r + b.r)*(a.r + b.r);
}

// -------------------- メインループ --------------------
function loop(t){
  if(!running) return;
  const dt = (t-last)/1000;
  last = t;

  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// 初回開始
last = performance.now();
loop(last);
</script>
</body>
</html>
