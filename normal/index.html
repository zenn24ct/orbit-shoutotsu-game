<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Asteroid Roll — Safe Load</title>
<style>
  html,body{
    height:100%;margin:0;
    background:#05070b;
    display:flex;align-items:center;justify-content:center;
    font-family:system-ui;
  }
  canvas{
    background:#0a121d;
    border-radius:8px;
    box-shadow:0 8px 28px rgba(0,0,0,.6);
    cursor:crosshair;
  }
  #hud{
    position:fixed;top:12px;left:12px;
    color:#cfe7ff;font-size:14px;font-weight:600;
  }
  #msg{
    position:fixed;top:50%;left:50%;
    transform:translate(-50%,-50%);
    background:rgba(0,0,0,.45);
    padding:12px 18px;border-radius:8px;
    color:#fff;font-size:18px;text-align:center;
    display:none;
  }
</style>
</head>
<body>

<canvas id="game" width="480" height="640"></canvas>
<div id="hud">Score: 0</div>
<div id="msg">Game Over<br>Click to Restart</div>

<script>
// -------------------- 設定 --------------------
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const W = canvas.width, H = canvas.height;

let last = 0, running = false;
let score = 0;
let gameOver = false;

// 判定用プレイヤー半径（見た目に合わせて調整）
const PLAYER_R = 22;

// ヒステリシス（当たり確定に必要な連続時間 s）
const HIT_CONFIRM_TIME = 0.06;

// 画像の相対パス（画像は同じフォルダか ./images に置く想定）
const IMAGE_BASE = "./images/"; // 例: ./images/rocket.png
// -------------------- 画像プリロードユーティリティ --------------------
function loadImage(src, timeout = 5000) {
  return new Promise(resolve => {
    const img = new Image();
    let done = false;
    const clear = (obj) => {
      if (!done) {
        done = true;
        resolve(obj);
      }
    };
    img.onload = () => clear({ img, ok: true });
    img.onerror = (e) => {
      console.warn("image load error:", src, e);
      clear({ img, ok: false });
    };
    // timeout fallback
    setTimeout(()=> clear({ img, ok: false }), timeout);
    img.src = src;
  });
}

// 画像リファレンス格納
const IMG = {
  rocket: { img: null, ok: false },
  s1:     { img: null, ok: false },
  s2:     { img: null, ok: false }
};

// プリロードしてからゲーム開始
async function preloadAll() {
  // パスは環境に合わせて修正してください
  const r1 = await loadImage(IMAGE_BASE + "rocket.png");
  const r2 = await loadImage(IMAGE_BASE + "inseki01.png");
  const r3 = await loadImage(IMAGE_BASE + "inseki02.png");
  IMG.rocket = r1;
  IMG.s1     = r2;
  IMG.s2     = r3;

  console.log("preload result:", { rocket: IMG.rocket.ok, s1: IMG.s1.ok, s2: IMG.s2.ok });

  startGameLoop();
}

// -------------------- ゲームデータ --------------------
const player = {
  x: W/2,
  y: H - 60,
  r: PLAYER_R,
  speed: 320,
  hitTimer: 0,
  powerUpTime: 0
};

let stones = [];
const stoneTypes = [
  { ref: "s1", size: 42, speedMin: 80, speedMax: 150 },
  { ref: "s2", size: 66, speedMin: 50, speedMax: 120 }
];

function rand(a,b){ return Math.random()*(b-a)+a; }

function spawnStone(){
  const t = Math.random() < 0.5 ? 0 : 1;
  const type = stoneTypes[t];
  return {
    x: Math.random()*(W-type.size) + type.size/2,
    y: -type.size,
    r: type.size/2,
    vy: rand(type.speedMin, type.speedMax),
    rot: Math.random()*Math.PI*2,
    rotSpd: (Math.random()-0.5)*3,
    imgRef: type.ref,
    size: type.size,
    isHitted: false,
    _remove: false,
    hitTimer: 0 // 当該石が連続で衝突判定されている時間
  };
}

// -------------------- 入力 --------------------
const keys = {};
window.addEventListener("keydown", e=>{ keys[e.key] = true; });
window.addEventListener("keyup",   e=>{ keys[e.key] = false; });

canvas.addEventListener("mousemove", e=>{
  const r = canvas.getBoundingClientRect();
  const mx = (e.clientX - r.left) * (canvas.width / r.width);
  player.x = mx;
});

canvas.addEventListener("click", ()=>{
  if(gameOver) restart();
});

// -------------------- 再スタート --------------------
function restart(){
  stones = [];
  score = 0;
  gameOver = false;
  document.getElementById("msg").style.display = "none";
  last = performance.now();
  running = true;
  loop(last);
}

// -------------------- 判定ユーティリティ --------------------
function circleCircleCollision(ax,ay,ar, bx,by,br){
  const dx = ax-bx, dy = ay-by;
  return (dx*dx + dy*dy) < (ar+br)*(ar+br);
}

// -------------------- 更新 --------------------
function update(dt){
  if(gameOver) return;

  // パワーアップ時間経過（将来拡張用）
  if(player.powerUpTime > 0){
    player.powerUpTime = Math.max(0, player.powerUpTime - dt);
  }

  // 入力
  let move = 0;
  if(keys["ArrowLeft"] || keys["a"]) move -= 1;
  if(keys["ArrowRight"] || keys["d"]) move += 1;
  player.x += move * player.speed * dt;
  player.x = Math.max(player.r, Math.min(W - player.r, player.x));

  // 隕石生成
  if(Math.random() < 0.04) stones.push(spawnStone());

  // 隕石更新
  for(let i = stones.length - 1; i >= 0; i--){
    const s = stones[i];
    s.y += s.vy * dt;
    s.rot += s.rotSpd * dt;

    // 画面完全外へ出たら除去（落下で即死はさせない）
    if(s.y - s.r > H + 100){ stones.splice(i,1); continue; }

    // 衝突判定（円-円）
    const collidingNow = circleCircleCollision(s.x, s.y, s.r, player.x, player.y, player.r);

    if(collidingNow){
      s.hitTimer += dt;
    } else {
      s.hitTimer = 0;
    }

    // 連続時間が閾値を超えたら確定ヒット
    if(s.hitTimer >= HIT_CONFIRM_TIME){
      // 無敵（将来の powerUp 実装）判定
      if(player.powerUpTime > 0){
        // 弾く処理
        const diffX = s.x - player.x;
        s.vx = diffX * 6;
        s.vy = -Math.abs(s.vy) * 1.2;
        s.isHitted = true;
        score += 10;
        s.hitTimer = 0;
        continue;
      }
      // 実際にぶつかった＝ゲームオーバー
      gameOver = true;
      running = false;
      document.getElementById("msg").style.display = "block";
      return;
    }

    // 石同士の当たり（弾かれた石のみ）
    if(s.isHitted){
      for(let j = 0; j < stones.length; j++){
        if(i === j) continue;
        const o = stones[j];
        if(!o) continue;
        if(circleCircleCollision(s.x, s.y, s.r, o.x, o.y, o.r)){
          s._remove = true;
          o._remove = true;
          score += 150;
          break;
        }
      }
    }
  }

  // _remove フラグの石を削除
  stones = stones.filter(s => !s._remove);

  // スコア加算（秒）
  score += dt;
  document.getElementById("hud").textContent = "Score: " + Math.floor(score);
}

// -------------------- 描画（安全に drawImage を呼ぶ） --------------------
function safeDrawImage(imgObj, dx, dy, dw, dh){
  // imgObj can be {img, ok} or HTMLImageElement
  let img = null, ok = false;
  if(imgObj && imgObj.img !== undefined){ img = imgObj.img; ok = !!imgObj.ok; }
  else { img = imgObj; ok = !!(img && img.complete && img.naturalWidth > 0); }

  if(ok && img && img.complete && img.naturalWidth > 0){
    ctx.drawImage(img, dx, dy, dw, dh);
    return true;
  }
  return false;
}

function draw(){
  ctx.clearRect(0,0,W,H);

  // 隕石描画
  stones.forEach(s=>{
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.rotate(s.rot);

    const imgRef = s.imgRef === "s2" ? IMG.s2 : IMG.s1;
    if(!safeDrawImage(imgRef, -s.size/2, -s.size/2, s.size, s.size)){
      // 代替：円で描画
      ctx.beginPath();
      ctx.fillStyle = s.isHitted ? "#00ccff" : "#d36b4a";
      ctx.arc(0, 0, s.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.06)";
      ctx.stroke();
    }

    ctx.restore();
  });

  // プレイヤー描画（画像が使えれば画像、なければ矩形）
  if(!safeDrawImage(IMG.rocket, player.x - player.r, player.y - player.r, player.r*2, player.r*2)){
    ctx.fillStyle = "#0099ff";
    ctx.fillRect(player.x - player.r, player.y - player.r, player.r*2, player.r*2);
  }
}

// -------------------- メインループ --------------------
function loop(t){
  if(!running) return;
  const dt = Math.min((t - last)/1000, 0.1);
  last = t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// ゲーム開始（プリロード後に呼ぶ）
function startGameLoop(){
  // safety: ensure last is set
  last = performance.now();
  running = true;
  loop(last);
}

// 最初にプリロードしてから開始する
preloadAll().catch(e=>{
  console.error("preload error:", e);
  // 失敗しても一応ゲームは開始する（画像はフォールバック描画）
  startGameLoop();
});

// 便利: 開発中に console から直接開始/再読み込みしたいとき用
window.__GAME = { IMG, restart };
</script>
</body>
</html>
