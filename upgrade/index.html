<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Asteroid Chain Reaction — 判定書き直し版（安全描画）</title>
<style>
  html,body{height:100%;margin:0;background:#05070b;display:flex;align-items:center;justify-content:center;font-family:system-ui;overflow:hidden;}
  canvas{background:#0a121d;border-radius:8px;box-shadow:0 0 30px rgba(0,150,255,0.2);cursor:crosshair;}
  #hud{position:fixed;top:12px;left:12px;color:#cfe7ff;font-size:18px;font-weight:600;text-shadow:0 0 10px rgba(0,150,255,0.5);pointer-events:none;}
  #msg{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);padding:24px 36px;border-radius:12px;color:#fff;font-size:24px;text-align:center;display:none;border:2px solid #444;pointer-events:none;}
</style>
</head>
<body>

<canvas id="game" width="480" height="640"></canvas>
<div id="hud">Score: 0</div>
<div id="msg">GAME OVER<br><span style="font-size:14px">Click to Restart</span></div>

<script>
// ---------------- CONFIG ----------------
const COLLISION_MODE = "circle"; // "circle" or "rect"
const PLAYER_COLLISION_RADIUS = 18;
const HIT_CONFIRM_TIME = 0.06; // seconds
const DEBUG = false;

// 画像ベースパス（環境に合わせて変更してください）
const IMAGE_BASE = "./images/";

// ---------------- 基本 ----------------
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const W = canvas.width, H = canvas.height;
let last = 0, running = false;
let score = 0;
let gameOver = false;

// ---------------- 画像プリロードユーティリティ ----------------
function loadImage(src, timeout = 5000) {
  return new Promise(resolve => {
    const img = new Image();
    let done = false;
    const finish = (obj) => { if(!done){ done = true; resolve(obj); } };
    const to = setTimeout(()=> finish({ img, ok: false, src, reason: 'timeout' }), timeout);
    img.onload = () => { clearTimeout(to); finish({ img, ok: true, src }); };
    img.onerror = (e) => { clearTimeout(to); console.warn("image load error", src, e); finish({ img, ok: false, src, reason: 'error' }); };
    img.src = src;
  });
}

// IMG オブジェクトにプリロード結果を入れる
const IMG = {
  rocket: { img: null, ok: false },
  s1:     { img: null, ok: false },
  s2:     { img: null, ok: false }
};

async function preloadAll() {
  const p = await Promise.all([
    loadImage(IMAGE_BASE + "rocket.png"),
    loadImage(IMAGE_BASE + "inseki01.png"),
    loadImage(IMAGE_BASE + "inseki02.png")
  ]);
  IMG.rocket = p[0];
  IMG.s1     = p[1];
  IMG.s2     = p[2];

  console.log("Image preload:", { rocket: IMG.rocket.ok, s1: IMG.s1.ok, s2: IMG.s2.ok });

  // 開始
  startGameLoop();
}

// ---------------- ゲームデータ ----------------
const player = {
  x: W/2, y: H - 80,
  w: 48, h: 48,
  speed: 450,
  powerUpTime: 0
};

let stones = [];
const stoneTypes = [
  { ref: "s1", size: 42, speedMin: 90, speedMax: 160, type: 'normal' },
  { ref: "s2", size: 66, speedMin: 60, speedMax: 130, type: 'normal' },
  { ref: null, size: 30, speedMin: 180, speedMax: 240, type: 'gold' }
];

function rand(a,b){ return Math.random()*(b-a)+a; }

function spawnStone(){
  const r = Math.random();
  const t = r < 0.12 ? 2 : (r < 0.6 ? 0 : 1);
  const type = stoneTypes[t];
  return {
    x: Math.random() * (W - type.size) + type.size/2,
    y: -type.size,
    r: type.size/2,
    vx: (Math.random()-0.5)*50,
    vy: rand(type.speedMin, type.speedMax),
    rot: Math.random()*Math.PI*2,
    rotSpd: (Math.random()-0.5)*5,
    imgRef: type.ref, // "s1"/"s2" or null for gold
    size: type.size,
    type: type.type,
    isHitted: false,
    _remove: false,
    hitTimer: 0
  };
}

// ---------------- 入力 ----------------
const keys = {};
window.addEventListener("keydown", e=>{ keys[e.key]=true; });
window.addEventListener("keyup", e=>{ keys[e.key]=false; });

canvas.addEventListener("mousemove", e=>{
  const r = canvas.getBoundingClientRect();
  const mx = (e.clientX - r.left) * (canvas.width / r.width);
  player.x = mx;
});
canvas.addEventListener("mousedown", ()=>{ if(gameOver) restart(); });

// ---------------- 再スタート ----------------
function restart(){
  stones = []; score = 0; player.powerUpTime = 0; gameOver = false;
  document.getElementById("msg").style.display = "none";
  last = performance.now();
  running = true;
  loop(last);
}

// ---------------- 判定ユーティリティ ----------------
function circleCircleCollision(ax,ay,ar, bx,by,br){
  const dx = ax-bx, dy = ay-by;
  return (dx*dx + dy*dy) < (ar+br)*(ar+br);
}

function circleRectCollision(cx,cy,cr, rect){
  const closestX = Math.max(rect.left, Math.min(cx, rect.left + rect.width));
  const closestY = Math.max(rect.top, Math.min(cy, rect.top + rect.height));
  const dx = cx - closestX, dy = cy - closestY;
  return (dx*dx + dy*dy) < (cr*cr);
}

function playerRect(){
  return { left: player.x - player.w/2, top: player.y - player.h/2, width: player.w, height: player.h };
}

// ---------------- 更新 ----------------
function update(dt){
  if(gameOver) return;

  if(player.powerUpTime > 0){
    player.powerUpTime = Math.max(0, player.powerUpTime - dt);
  }

  if(keys["ArrowLeft"] || keys["a"]) player.x -= player.speed * dt;
  if(keys["ArrowRight"] || keys["d"]) player.x += player.speed * dt;
  player.x = Math.max(player.w/2, Math.min(W-player.w/2, player.x));

  if(Math.random() < 0.035) stones.push(spawnStone());

  const pRect = playerRect();
  const pCircle = { x: player.x, y: player.y, r: PLAYER_COLLISION_RADIUS };

  for(let i=0;i<stones.length;i++){
    const s = stones[i];
    if(!s) continue;
    s.x += s.vx * dt;
    s.y += s.vy * dt;
    s.rot += s.rotSpd * dt;

    if(s.x < -100 || s.x > W+100 || s.y > H + 200){
      s._remove = true;
      continue;
    }

    let colliding = false;
    if(COLLISION_MODE === "circle"){
      colliding = circleCircleCollision(s.x, s.y, s.r, pCircle.x, pCircle.y, pCircle.r);
    } else {
      colliding = circleRectCollision(s.x, s.y, s.r, pRect);
    }

    if(colliding) s.hitTimer += dt; else s.hitTimer = 0;

    if(s.hitTimer >= HIT_CONFIRM_TIME){
      if(s.type === 'gold'){
        player.powerUpTime = 6.0;
        score += 500;
        s._remove = true;
        s.hitTimer = 0;
        continue;
      }
      if(player.powerUpTime > 0){
        const diffX = s.x - player.x;
        s.vx = diffX * 10;
        s.vy = -Math.abs(s.vy) * 1.4;
        s.isHitted = true;
        score += 10;
        s.hitTimer = 0;
        continue;
      }
      gameOver = true;
      running = false;
      document.getElementById("msg").style.display = "block";
      return;
    }

    if(s.isHitted && !s._remove){
      for(let j=0;j<stones.length;j++){
        if(i===j) continue;
        const o = stones[j];
        if(!o || o._remove) continue;
        if(circleCircleCollision(s.x,s.y,s.r, o.x,o.y,o.r)){
          s._remove = true; o._remove = true; score += 150; break;
        }
      }
    }
  }

  stones = stones.filter(s => !s._remove);
  document.getElementById("hud").textContent = "Score: " + Math.floor(score);
}

// ---------------- 描画（安全に drawImage） ----------------
function safeDrawImage(imgEntry, dx, dy, dw, dh){
  // imgEntry is { img, ok } from preload or HTMLImageElement
  let img = null, ok = false;
  if(imgEntry && imgEntry.img !== undefined){
    img = imgEntry.img; ok = !!imgEntry.ok;
  } else {
    img = imgEntry; ok = !!(img && img.complete && img.naturalWidth > 0);
  }
  if(ok && img && img.complete && img.naturalWidth > 0){
    ctx.drawImage(img, dx, dy, dw, dh);
    return true;
  }
  return false;
}

function draw(){
  ctx.clearRect(0,0,W,H);

  // 隕石
  stones.forEach(s=>{
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.rotate(s.rot);

    if(s.type === 'gold'){
      ctx.fillStyle = "#ffd700"; ctx.beginPath(); ctx.arc(0,0,s.r,0,Math.PI*2); ctx.fill();
    } else {
      const ref = s.imgRef === "s2" ? IMG.s2 : IMG.s1;
      if(!safeDrawImage(ref, -s.size/2, -s.size/2, s.size, s.size)){
        ctx.beginPath(); ctx.fillStyle = s.isHitted ? "#00ccff" : "#888"; ctx.arc(0,0,s.r,0,Math.PI*2); ctx.fill();
      }
    }

    if(DEBUG){
      ctx.fillStyle = "#fff"; ctx.font = "12px monospace"; ctx.fillText((s.hitTimer).toFixed(2), -s.size/2, -s.size/2 - 6);
    }
    ctx.restore();
  });

  // プレイヤー
  ctx.save();
  if(player.powerUpTime > 0){ ctx.shadowBlur = 30; ctx.shadowColor = "#ff0066"; } else ctx.shadowBlur = 0;
  if(!safeDrawImage(IMG.rocket, player.x - player.w/2, player.y - player.h/2, player.w, player.h)){
    ctx.fillStyle = player.powerUpTime > 0 ? "#ff0066" : "#0099ff";
    ctx.fillRect(player.x - player.w/2, player.y - player.h/2, player.w, player.h);
  }
  ctx.restore();

  if(DEBUG){
    const pr = playerRect();
    ctx.save(); ctx.setLineDash([4,3]); ctx.strokeStyle = "lime"; ctx.strokeRect(pr.left, pr.top, pr.width, pr.height); ctx.setLineDash([]); ctx.restore();
    if(COLLISION_MODE === "circle"){ ctx.beginPath(); ctx.strokeStyle = "cyan"; ctx.arc(player.x, player.y, PLAYER_COLLISION_RADIUS, 0, Math.PI*2); ctx.stroke(); }
    stones.forEach(s=>{ ctx.beginPath(); ctx.strokeStyle = s.hitTimer > 0 ? "red" : "rgba(255,255,255,0.15)"; ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.stroke(); });
  }
}

// ---------------- ループ ----------------
function loop(t){
  if(!running) return;
  const dt = Math.min((t-last)/1000, 0.1);
  last = t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

function startGameLoop(){
  last = performance.now();
  running = true;
  loop(last);
}

// プリロードして開始
preloadAll().catch(e=>{
  console.error("preloadAll failed:", e);
  // それでもゲームを開始したい場合
  startGameLoop();
});

// デバッグ用アクセス
window.__GAME = { IMG, restart };
</script>
</body>
</html>
